# Руководство по стилю проекта UE4 от [Gamemakin](https://gamemak.in), перевод КоМиГо {

*Наиболее разумный подход к Unreal Engine 4*

Создание этого руководства было вдохновлено, по большей части, [стайл-гайдом Javascript от Airbnb (En)](https://github.com/airbnb/javascript).

[![Analytics](https://ga-beacon.appspot.com/UA-80567399-1/repo?useReferrer)](#)

<a name="translations"></a>
##### Английские термины и их русификация (Levels/Maps)
_(От переводчика)_ Многие вещи будут называться в английском языке, но спокойно мешаться с русскими вариантами. Так, стайл-гайд — это руководство по стилю, ассет — материал для разработки.

## Плагин для автопроверки Unreal Engine 4 

Автоматизированный способ проверки соответствия вашего проекта этому руководству можно найти на [маркете Unreal Engine](https://www.unrealengine.com/marketplace/linter). Код плагина станет бесплатен, но чтобы использовать этот плагин без сборки UE4 по его исходникам, понадобится использовать версию с маркета.

## Как ссылаться на этот документ

Все разделы этого руководства пронумерованы для быстрой адресации. К английской (и самой актуальной) версии руководства можно сослаться, просто добавив хеш-тег ко ссылке http://ue4.style
Например, если вы хотите отправить своему другу ссылку на первый принцип руководства, добавьте `#0.1` в конец ссылки — получится http://ue4.style#0.1.

## Repo Notice

This repo is now located at https://github.com/Allar/ue5-style-guide. The default branch of this repository has been renamed `main`.

## This is currently for UE4. For UE5/v2, see the v2 branch.
## Linter and Style Guide Documentation

More technical documentation regarding Linter and the Style Guide can be found at our [ReadTheDocs](https://ue4-style-guide.readthedocs.io/en/latest/) page.

## Discuss This Style Guide

Gamemakin LLC has a public Discord channel at http://discord.gamemak.in with a #linter channel if you'd like to discuss all things style guide and Linter plugin.

## Форки и переводы

Если вы создали примечательный форк, который не получится организовать в pull-request, отправьте pull request на его добавление сюда. Так же делаем и с переводами.

* [Оригинальная, английская версия](https://github.com/Allar/ue4-style-guide/README.md) by Allar
* [Корейская версия](https://github.com/ymkim50/ue4-style-guide/blob/master/README_Kor.md) by ymkim50
* [Японская версия](https://github.com/akenatsu/ue4-style-guide/blob/master/README.jp.md) by akenatsu
* [Китайская версия](https://github.com/skylens-inc/ue4-style-guide/blob/master/README.md) by Beijing Skylens Tech

## Основные термины

<a name="terms-level-map"></a>
##### Карты/Уровни (Levels/Maps)

Слово 'карта' в основном используется в обозначении слова 'уровень' — эти слова считаем взаимозаменяемыми. То же и с английскими Level и Map. О терминологии уровня смотрите [здесь (En)](https://en.wikipedia.org/wiki/Level_(video_gaming)) и [здесь (RU)](https://ru.wikipedia.org/wiki/%D0%A3%D1%80%D0%BE%D0%B2%D0%B5%D0%BD%D1%8C_(%D0%B8%D0%B3%D1%80%D1%8B)).

##### Identifiers
An `Identifier` is anything that resembles or serves as a "name". For example, the name of an asset, or the name of a material later, or a blueprint property, a variable, or a folder name, or for a data table row name, etc...

<a name="terms-cases"></a>
##### Использование верхнего и нижнего регистра

Есть несколько разных способов, как называть вещи. Вот самые популярные методики:

> ###### ДельфиСтиль
>
> Каждое слово начинается с большой буквы, а всё слово пишется без пробелов, нижних пробелов, дефисов и т.п. Например: `DesertEagle`, `StyleGuide`, `ASeriesOfWords`.
> 
> ###### верблюжийСтиль
>
> Похож на ДельфиСтиль, но первая буква пишется в нижнем регистре. Например: `desertEagle`, `styleGuide`, `aSeriesOfWords`.
>
> ###### Змеиный_стиль (а.к.а. snake_case)
>
> Использование регистра в начале слов не определено, но слова разделяются нижним пробелом. Например: `desert_Eagle`, `Style_Guide`, `a_Series_of_Words`.

<a name="terms-var-prop"></a>
##### Variables / Properties

The words 'variable' and 'property' in most contexts are interchangable. If they are both used together in the same context however:

<a name="terms-property"></a>
###### Property 
Usually refers to a variable defined in a class. For example, if `BP_Barrel` had a variable `bExploded`, `bExploded` may be referred to as a property of `BP_Barrel`. 

When in the context of a class, it is often used to imply accessing previously defined data.

<a name="terms-variable"></a>
###### Variable 
Usually refers to a variable defined as a function argument or a local variable inside a function.

When in the context of a class, it is often used to convey discussion about its definition and what it will hold.

<a name="0"></a>
## 0. Принципы

Эти принципы были адаптированы под UE из [руководства по стилю idomatic.js (En)](https://github.com/rwaldron/idiomatic.js/).

<a name="0.1"></a>
### 0.1 Если в вашем проекте UE4 уже используется руководство стиля, вы должны следовать ему

Если вы работаете над существующим проектом, или в команде, которая уже использует руководство стиля, вы должны ему (руководству) следовать. Во всех различиях между имеющимся и новым руководством стиля приоритет отдаётся имеющемуся.

Руководство по стилю, при этом, постоянно меняющийся документ, и рекомендуется предлагать вносить правки в ваше имеющееся руководство по стилю (и в этот документ), если это принесёт реальную пользу сообществу UE.

> #### "Споры по поводу стиля не имеют смысла. Должно быть руководство по стилю, а вы должны следовать ему".
> [_Rebecca Murphey_](https://rmurphey.com)

<a name="0.2"></a>
### 0.2 Вся структура проекта, материалы для разработки, код в любом Unreal Engine 4 проекте должны выглядеть так, будто всё это создано одним человеком — не важно, как много людей на самом деле участвует

Смена проекта не должна требовать от вас переучиваться под новый стиль и структуру. Использование руководства по стилю избавит вас от гадания на кофейной гуще и неопределённости.

Также, руководство по стилю улучшает продуктивность создателей контента и управляемость проектом, т.к. каждому не требуется думать о стиле — достаточно просто воспользоваться руководством. Это руководство по стилю разрабатывается с учётом лучших практик, и его использование снизит частоту появления трудно отслеживаемых проблем.

<a name="0.3"></a>
### 0.3 Мы помогаем друзьям следовать хорошему стилю

Если вы видите, что кто-то работает не по вашему руководству стиля, или вовсе без какого-либо — объясните это тому человеку.

При работе в комаде и во время обсуждений в духе [Unreal Slackers (EN)](http://join.unrealslackers.org/) постоянство стиля также помогает быстро найти отклик на свою проблему. Никому не хочется рыться в макаронах блюпринтов и изучать непонятные названия материалов для разработки.

Если вы помогаете тому, кто следует другому, но постоянному и понятному руководству стиля, вы сможете к нему адаптироваться. Если вы увидили, что этот кто-то не следует какому-либо руководству стиля, отправьте ему ссылку на этот документ.

<a name="0.4"></a>
### 0.4 Команда без руководства стиля — не моя команда 

Одним из первых ваших вопросах при вступлении в команду разработчиков на UE4 должен быть "У вас есть руководство стиля?" Если его нет, то следует с подозрением относиться ко способности этих людей работать в команде.

<a name="0.5"></a>
### 0.5 Don't Break The Law

Gamemakin LLC is not a lawyer, but please don't introduce illegal actions and behavior to a project, including but not limited to:

* Don't distribute content you don't have the rights to distribute
* Don't infringe on someone else's copyrighted or trademark material
* Don't steal content
* Follow licensing restrictions on content, e.g. attribute when attributions are needed

<a name="00"></a>
## 00. Globally Enforced Opinions

@TODO: Make this section 1 and update this document accordingly. Or maybe we don't?

<a name="00.1"></a>
### 00.1 Forbidden Characters

#### Identifiers

In any `Identifier` of any kind, **never** use the following unless absolutely forced to:

* White space of any kind
* Backward slashes `\`
* Symbols i.e. `#!@$%`
* Any Unicode character

Any `Identifier` should strive to only have the following characters when possible (the RegEx `[A-Za-z0-9_]+`)

* ABCDEFGHIJKLMNOPQRSTUVWXYZ
* abcdefghijklmnopqrstuvwxyz
* 1234567890
* _ (sparingly)


The reasoning for this is this will ensure the greatest compatibility of all data across all platforms across all tools, and help prevent downtime due to potentially bad character handling for identifiers in code you don't control.

<a name="toc"></a>
## Содержание

> 1. [Соглашение о наименованиях](#anc)
> 1. [Структура папок проекта](#structure)
> 1. [Блупринты](#bp)
> 1. [Static Meshes](#s)
> 1. [Particle Systems](#ps)
> 1. [Levels / Maps](#levels)
> 1. [Textures](#textures)

<a name="anc"></a>
<a name="1"></a>
## 1. Соглашение о наименованиях

Соглашение о наименованиях должно восприниматься как закон. В проекте, следующем соглашению о наименованиях, легко управлять ассетами, искать и обрабатывать их.

В большинстве случаев, ассетам присваивается префикс-аббревиатура на основе названия типа этого ассета + нижний пробел `_`.

<a name="prohibited-languages"></a>
<a name="1.0"></a>
### 1.0 Русский и иные языки (от переводчика)
Использование русских и иных языков в названиях ассетов строго запрещается. Нет ничего хуже, чем пытаться понять проект с французскими названиями, когда вы не владеете таким языком. Точно так же будет плохо зарубежным друзьям при разборе вашего проекта.

Такие проекты нельзя будет передавать лицам из других стран, когда вам потребуется помощь. Также, не-латинские символы могут вызвать ошибки при компиляции, преобразовании и в ходе других внутренних процессов UE4 и сторонних плагинов — такие ошибки будет трудно отловить и исправить, так что лучше не делайте их вообще.

*Не бойтесь пользоваться переводчиком*. Лучше чудаковатое название на английском, нежели написанное транслитом слово `Pchela`, или, того хуже, так и оставленное на русском `Пчела`.

<a name="base-asset-name"></a>
<a name="1.1"></a>
### 1.1 Базовое название - `Префик_БазовоеНазвание_Вариант_Суффикс`

У каждого ассета должно быть своё _базовое название_. Оно используется как средство логической группировки материалов разработки. Любой ассет, являющийся частью определённой логической группы, должен следовать стандарту  `Префик_БазовоеНазвание_Вариация_Суффикс`.

Использование схемы `Префик_БазовоеНазвание_Вариация_Суффикс` с её осознанием уже гарантирует создание "хороших" имён. Вот подробные правила по использованию этой схемы:

* `Префикс` и `Суффикс` определяется типом ассета, исходя из таблиц [Модификаторов имён ассетов](#asset-name-modifiers).
* `Базовое название` определяется коротким и легко отличимым названием касательно предметной области вашей группы ассетов. Например, если у вас есть персонаж Вася, то все ассеты Васи должны содержать `БазовоеНазвание` = `Vasya`.
* Для особенных или уникальных вариантов ассета используйте `Вариант` — короткое и легко различимое имя, отражающее логическую группировку ассетов, образующих подмножество на основе базового имя ассета. Например, если у Васи есть несколько скинов, то у этих скинов должно быть всё то же базовое имя `Vasya`, но также и `Вариант`. "Злой" скин можно назвать `Vasya_Evil`, а скин "Ретро"— `Vasya_Retro`.
* Для уникальных но схожих ассетов, относящихся к одной группе, добавляется нумерующий `Вариант` — двузначное число, нумерация которого начинается с `01`. Например, если ваш художник окружения генерирует валуны, которые нельзя просто так взять и назвать, то их можно назвать как `Rock_01`, `Rock_02`, `Rock_03`, и т.д. За исключением редких случаев, не используйте трёхзначное число. Если у вас более 100 ассетов в одной группе, вам следует разбить её на несколько других, используя другие базовые названия или варианты.
* В зависимости от того, как у вас создаются ассеты, вы можете использовать несколько имён-вариантов, друг за другом. Например, если вы создаёте ассеты для пола, вам будет нужно использовать базовое имя `Flooring` с вариантами вроде `Flooring_Marble_01`, `Flooring_Maple_01`, `Flooring_Tile_Squares_01`.

<a name="1.1-examples"></a>
#### 1.1 Примеры

##### 1.1e1 Вася

| Тип ассета (RU)          |Тип ассета (EN)           | Название ассета                |
| ------------------------ | ------------------------ | ------------------------------ |
| Скелетный меш            | Skeletal Mesh            | SK_Bob                         |
| Материал                 | Material                 | M_Bob                          |
| Текстура (Diffuse/Albedo)| Texture (Diffuse/Albedo) | T_Bob_D                        |
| Текстура (Normal)        | Texture (Normal)         | T_Bob_N                        |
| Текстура (Злой Diffuse)  | Texture (Злой Diffuse)   | T_Bob_Evil_D                   |

##### 1.1e2 Валуны

| Тип ассета (RU)           | Тип ассета (EN)         | Название ассета                |
| ------------------------- | ----------------------- | ------------------------------ |
| Статичный меш (01)        | Static Mesh (01)        | S_Rock_01                      |
| Статичный меш (02)        | Static Mesh (02)        | S_Rock_02                      |
| Статичный меш (03)        | Static Mesh (03)        | S_Rock_03                      |
| Материал                  | Material                | M_Rock                         |
| Экземпляр материала (Снег)| Material Instance (Snow)| MI_Rock_Snow                   |

<a name="asset-name-modifiers"></a>
<a name="1.2"></a>
### 1.2 Модификаторы имён ассетов

Используйте эти таблицы наряду с [базовым названием](#base-asset-name), когда именуете ассеты.

#### Подразделы

> 1.2.1 [Часто используемые](#anc-common)

> 1.2.2 [Анимация](#anc-animations)

> 1.2.3 [Искусственный интеллект](#anc-ai)

> 1.2.4 [Блупринты](#anc-bp)

> 1.2.5 [Материалы](#anc-materials)

> 1.2.6 [Текстуры](#anc-textures)

> 1.2.7 [Разное](#anc-misc)

> 1.2.8 [Paper 2D](#anc-paper2d)

> 1.2.9 [Физика](#anc-physics)

> 1.2.10 [Звуки](#anc-sounds)

> 1.2.11 [Графический интерфейс пользователя](#anc-ui)

> 1.2.12 [Эффекты](#anc-effects)

<a name="anc-common"></a>
<a name="1.2.1"></a>
#### 1.2.1 Часто используемые

| Тип ассета (RU)      | Тип ассета (EN)    | Префикс      | Суффикс    | Примечания                          |
| -------------------- | ------------------ | ------------ | ---------- | ----------------------------------- |
| Карта / уровень      | Level / Map        |              |            | [Должны быть в папке `Maps`.](#2.4) |
| Уровень (постоянный) | Level (Persistent) |              | _P         |                                     |
| Уровень (аудио)      | Level (Audio)      |              | _Audio     |                                     |
| Уровень (освещение)  | Level (Lighting)   |              | _Lighting  |                                     |
| Уровень (геометрия)  | Level (Geometry)   |              | _Geo       |                                     |
| Уровень (геймплей)   | Level (Gameplay)   |              | _Gameplay  |                                     |
| Блупринт             | Blueprint          | BP_          |            |                                     |
| Материал             | Material           | M_           |            |                                     |
| Статичный меш        | Static Mesh        | S_           |            | Many use SM_. We use S_.            |
| Скелетный меш        | Skeletal Mesh      | SK_          |            |                                     |
| Текстура             | Texture            | T_           | _?         | См. [Текстуры](#anc-textures)       |
| Система частиц       | Particle System    | PS_          |            |                                     |
| Виджет-блупринт      | Widget Blueprint   | WBP_         |            |                                     |

<a name="anc-animations"></a>
<a name="1.2.2"></a>
#### 1.2.2 Анимация

| Тип ассета (RU)             | Тип ассета (EN)       | Префикс    | Суффикс    | Примечания               |
| --------------------------- | --------------------- | ---------- | ---------- | ------------------------ |
| Сдвиг прицела               | Aim Offset            | AO_        |            |                          |
| Сдвиг прицела 1D            | Aim Offset 1D         | AO_        |            |                          |
| Блюпринт анимации           | Animation Blueprint   | ABP_       |            |                          |
| Композиция анимации         | Animation Composite   | AC_        |            |                          |
| Монтаж анимации             | Animation Montage     | AM_        |            |                          |
| Последовательность анимаций | Animation Sequence    | A_         |            |                          |
| Пространство смешивания     | Blend Space           | BS_        |            |                          |
| Пространство смешивания 1D  | Blend Space 1D        | BS_        |            |                          |
| Последовательность уровня   | Level Sequence        | LS_        |            |                          |
| Точка смешивания            | Morph Target          | MT_        |            |                          |
| Paper Flipbook              | Paper Flipbook        | PFB_       |            |                          |
| Риг                         | Rig                   | Rig_       |            |                          |
| Скелетный меш               | Skeletal Mesh         | SK_        |            |                          |
| Скелет                      | Skeleton              | SKEL_      |            |                          |

<a name="anc-ai"></a>
<a name="1.2.3"></a>
### 1.2.3 Искусственный интеллект

| Тип ассета (RU)         | Тип ассета (EN)   | Префикс      | Суффикс    | Примечания |
| ----------------------- | ----------------- | ------------ | ---------- | ---------- |
| ИИ контроллер           | AI Controller     | AIC_         |            |            |
| Дерево поведений        | Behavior Tree     | BT_          |            |            |
| Доска состояний         | Blackboard        | BB_          |            |            |
| Декторатор              | Decorator         | BTDecorator_ |            |            |
| Сервис                  | Service           | BTService_   |            |            |
| Задание                 | Task              | BTTask_      |            |            |
|                         | Environment Query | EQS_         |            |            |
|                         | EnvQueryContext   | EQS_         | Context    |            |

<a name="anc-bp"></a>
<a name="1.2.4"></a>
### 1.2.4 Блупринты

| Тип ассета (RU)             | Тип ассета (EN)            | Префикс       | Суффикс   | Примечания                       |
| --------------------------- | -------------------------- | ------------- | --------- | -------------------------------- |
| Блупринт                    | Blueprint                  | BP_           |           |                                  |
|                             | Blueprint Component        | BP_	       | Component | I.e. BP_InventoryComponent       |
| Библиотека блупринт-функций | Blueprint Function Library | BPFL_         |           |                                  |
| Блупринт-интерфейс          | Blueprint Interface        | BPI_          |           |                                  |
| Библиотека бупринт-макросов | Blueprint Macro Library    | BPML_         |           | По возможности не используйте библиотеки макросов вообще |
| Перечисление                | Enumeration                | E             |           | Без нижнего пробела              |
| Структура                   | Structure                  | F или S       |           | Без нижнего пробела              |
|                             | Tutorial Blueprint         | TBP_          |           |                                  |
| Блупринт-виджет             | Widget Blueprint           | WBP_          |           |                                  |

<a name="anc-materials"></a>
<a name="1.2.5"></a>
### 1.2.5 Материалы

| Тип ассета (RU)               | Тип ассета (En)               | Префикс      | Суффикс | Примечания                |
| ----------------------------- | ----------------------------- | ------------ | ------- | ------------------------- |
| Материал                      | Material                      | M_           |         |                           |
| Материал пост-обработки       | Material (Post Process)       | PP_          |         |                           |
| Функция материалов            | Material Function             | MF_          |         |                           |
| Экземпляр материала           | Material Instance             | MI_          |         |                           |
| Материал Parameter Collection | Material Parameter Collection | MPC_         |         |                           |
| Профиль подповерхности        | Subsurface Profile            | SP_          |         |                           |
| Физический материал           | Physical Materials            | PM_          |         |                           |
|                               | Decal                         | M_, MI_      | _Decal  |                           |

<a name="anc-textures"></a>
<a name="1.2.6"></a>
### 1.2.6 Текстуры

| Тип ассета (RU)                  | Тип ассета (EN)             | Префикс      | Суффикс    | Примечания                       |
| -------------------------------- | --------------------------- | ------------ | ---------- | -------------------------------- |
| Текстура                         | Texture                     | T_           |            |                                  |
| Текстура (Diffuse/Альбедо/Основной цвет)| Texture (Diffuse/Albedo/Base Color)| T_ | _D      |                                  |
| Текстура (Нормаль)               | Texture (Normal)            | T_           | _N         |                                  |
| Текстура (Грубость)              | Texture (Roughness)         | T_           | _R         |                                  |
| Текстура (Alpha/Прозрачность)    | Texture (Alpha/Opacity)     | T_           | _A         |                                  |
| Текстура (Нейтральный свет)      | Texture (Ambient Occlusion) | T_           | _O         |                                  |
| Текстура (Неровность)            | Texture (Bump)              | T_           | _B         |                                  |
| Текстура (Излучение)             | Texture (Emissive)          | T_           | _E         |                                  |
| Текстура (Маска)                 | Texture (Mask)              | T_           | _M         |                                  |
| Текстура (Блеск)                 | Texture (Specular)          | T_           | _S         |                                  |
|                                  | Texture (Metallic)          | T_           | _M         |                                  |
| Текстура (упакованная)           | Texture (Packed)            | T_           | _*         | См. примечание об [упаковке текстур](#anc-textures-packing). |
| Текстура-куб                     | Texture Cube                | TC_          |            |                                  |
| Текстура-медиа                   | Media Texture               | MT_          |            |                                  |
| Область прорисовки               | Render Target               | RT_          |            |                                  |
| Область прорисовки текстуры-куба | Cube Render Target          | RTC_         |            |                                  |
| Профиль освещения                | Texture Light Profile       | TLP          |            |                                  |

<a name="anc-textures-packing"></a>
<a name="1.2.6.1"></a>
#### 1.2.6.1 Упаковка текстур
Упаковка сразу нескольких слоёв информации в одну текстуру — стандартная практика. Примером служит упаковка текстур Emissive, Roughness, Ambient Occlusion как красный, зелёный и синий каналы одной текстуры. Чтобы построить суффикс для таких текстур, просто последовательно запишите суффиксы отдельных масок из таблицы выше, напр. `_ERO`.

> Часто альфа-канал включают в карту Diffuse/Альбедо. Так как это стандартная практика, добавлять суффикс `A` в суффикс `_D` необязательно.

Упаковывать сразу 4 канала информации в одну текстуру (в RGBA) не рекомендуется, за исключением использования канала A как Alpha вместе с картой Diffuse/Альбедо.

<a name="anc-misc"></a>
<a name="1.2.7"></a>
### 1.2.7 Разное

| Тип ассета (RU)         | Тип ассета (EN)            | Префикс    | Суффикс    | Примечания                       |
| ----------------------- | -------------------------- | ---------- | ---------- | -------------------------------- |
| Анимированное векторное поле| Animated Vector Field  | VFA_       |            |                                  |
| Анимация камеры         | Camera Anim                | CA_        |            |                                  |
| Цветовая кривая         | Color Curve                | Curve_     | _Color     |                                  |
| Табличная кривая        | Curve Table                | Curve_     | _Table     |                                  |
| Набор данных            | Data Asset                 | *_         |            | Префикс основывается на классе   |
| Таблица данных          | Data Table                 | DT_        |            |                                  |
| Вещественная кривая     | Float Curve                | Curve_     | _Float     |                                  |
| Тип растительности      | Foliage Type               | FT_        |            |                                  |
| Эффект физического отклика| Force Feedback Effect    | FFE_       |            |                                  |
| Тип растительности      | Landscape Grass Type       | LG_        |            |                                  |
| Слой ландшафта          | Landscape Layer            | LL_        |            |                                  |
| Данные Matinee          | Matinee Data               | Matinee_   |            |                                  |
| Медиапроигрыватель      | Media Player               | MP_        |            |                                  |
| Библиотека объектов     | Object Library             | OL_        |            |                                  |
| Перенаправление         | Redirector                 |            |            | Перенаправление должно быть исправлено при первой возможности |
| Атлас спрайтов          | Sprite Sheet               | SS_        |            |                                  |
| Статичное векторное поле| Static Vector Field        | VF_        |            |                                  |
|                         | Substance Graph Instance   | SGI_       |            |                                  |
|                         | Substance Instance Factory | SIF_       |            |                                  |
| Настройка тач-интерфейса| Touch Interface Setup      | TI_        |            |                                  |
| Векторная кривая        | Vector Curve               | Curve_     | _Vector    |                                  |

<a name="anc-paper2d"></a>
<a name="1.2.8"></a>
### 1.2.8 Paper 2D

| Тип ассета (RU)         | Тип ассета (EN)         | Префикс    | Суффикс    | Примечания                        |
| ----------------------- | ----------------------- | ---------- | ---------- | -------------------------------- |
| Набор кадров            | Paper Flipbook          | PFB_       |            |                                  |
| Спрайт                  | Sprite                  | SPR_       |            |                                  |
| Группа атласов спрайтов | Sprite Atlas Group      | SPRG_      |            |                                  |
| Карта тайлов            | Tile Map                | TM_        |            |                                  |
| Тайлсет                 | Tile Set                | TS_        |            |                                  |

<a name="anc-physics"></a>
<a name="1.2.9"></a>
### 1.2.9 Физика

| Тип ассета (RU)         | Тип ассета (EN)         | Префикс    | Суффикс    | Примечания                       |
| ----------------------- | ----------------------- | ---------- | ---------- | -------------------------------- |
| Физический материал     | Physical Material       | PM_        |            |                                  |
| Физический ассет        | Physical Asset          | PHYS_      |            |                                  |
| Разрушаемый меш         | Destructible Mesh       | DM_        |            |                                  |

<a name="anc-sounds"></a>
<a name="1.2.10"></a>
### 1.2.10 Звуки

| Тип ассета (RU)         | Тип ассета (EN)         | Префикс    | Суффикс    | Примечания                       |
| ----------------------- | ----------------------- | ---------- | ---------- | -------------------------------- |
| Голос диалога           | Dialogue Voice          | DV_        |            |                                  |
| Запись диалога          | Dialogue Wave           | DW_        |            |                                  |
| Звукозапись медиа       | Media Sound Wave        | MSW_       |            |                                  |
| Эффект ревербации       | Reverb Effect           | Reverb_    |            |                                  |
| Затухание звука         | Sound Attenuation       | ATT_       |            |                                  |
| Класс звука             | Sound Class             |            |            | Без префиксов/суффиксов. Должен быть в отдельной папке `SoundClasses` |
| Очерёдность звуков      | Sound Concurrency       |            | _SC        | Должен быть назван на основе `SoundClass` |
| Композиция звуков       | Sound Cue               | A_         | _Cue       |                                  |
| Микс звуков             | Sound Mix               | Mix_       |            |                                  |
| Звукозапись             | Sound Wave              | A_         |            |                                  |

<a name="anc-ui"></a>
<a name="1.2.11"></a>
### 1.2.11 Графический интерфейс пользователя

| Тип ассета (RU)         | Тип ассета (EN)         | Префикс      | Суффикс    | Примечания                       |
| ----------------------- | ----------------------- | ------------ | ---------- | -------------------------------- |
| Шрифт                   | Font                    | Font_        |            |                                  |
| Кисть Slate             | Slate Brush             | Brush_       |            |                                  |
| Стиль виджета Slate     | Slate Widget Style      | Style_       |            |                                  |
| Виджет-блупринт         | Widget Blueprint        | WBP_         |            |                                  |

<a name="anc-effects"></a>
<a name="1.2.12"></a>
### 1.2.12 Эффекты

| Тип ассета (RU)         | Тип ассета (EN)         | Префикс    | Суффикс    | Примечания                       |
| ----------------------- | ----------------------- | ---------- | ---------- | -------------------------------- |
| Система частиц          | Particle System         | PS_        |            |                                  |
| Материал постобработки  | Material (Post Process) | PP_        |            |                                  |

**[⬆ Back to Top](#table-of-contents)**


<a name="2"></a>
<a name="structure"></a>
## 2. Структура папок проекта

Структура папок также должна восприниматься как закон. Она проекта так же важна, как и соглашение о наименованиях. Они тесно связаны, и нарушение правил любого из них приводит к ненужному хаосу в проекте.

Есть несколько способов организации контента UE4 проекта, но в этом гайде мы будем использовать структуру, которая основывается больше на возможности поиска и фильтрации в Content Browser — вместо того, чтобы под каждый тип материалов проекта создавать отдельную папку, будет использоваться фильтр/поиск в UE.

> Если вы используете [соглашение о наименованиях](#1.2) выше, то использование папок вроде `Meshes`, `Textures`, и `Materials` будет избыточным действием, т.к. все ассеты уже отсортированы по префиксу и могут быть отфильтрованы в content browser.

<a name="2e1"><a>
### 2e1 Пример организации папок проекта
<pre>
|-- Content
    |-- <a href="#2.2">GenericShooter</a>
        |-- Art
        |   |-- Industrial
        |   |   |-- Ambient
        |   |   |-- Machinery
        |   |   |-- Pipes
        |   |-- Nature
        |   |   |-- Ambient
        |   |   |-- Foliage
        |   |   |-- Rocks
        |   |   |-- Trees
        |   |-- Office
        |-- Characters
        |   |-- Bob
        |   |-- Common
        |   |   |-- <a href="#2.7">Animations</a>
        |   |   |-- Audio
        |   |-- Jack
        |   |-- Steve
        |   |-- <a href="#2.1.3">Zoe</a>
        |-- <a href="#2.5">Core</a>
        |   |-- Characters
        |   |-- Engine
        |   |-- <a href="#2.1.2">GameModes</a>
        |   |-- Interactables
        |   |-- Pickups
        |   |-- Weapons
        |-- Effects
        |   |-- Electrical
        |   |-- Fire
        |   |-- Weather
        |-- <a href="#2.4">Maps</a>
        |   |-- Campaign1
        |   |-- Campaign2
        |-- <a href="#2.8">MaterialLibrary</a>
        |   |-- Debug
        |   |-- Metal
        |   |-- Paint
        |   |-- Utility
        |   |-- Weathering
        |-- Placeables
        |   |-- Pickups
        |-- Weapons
            |-- Common
            |-- Pistols
            |   |-- DesertEagle
            |   |-- RocketPistol
            |-- Rifles
</pre>

Предпосылки формирования именно такой структуры проекта описаны ниже.

### Подразделы

> 2.1 [Названия папок](#structure-folder-names)

> 2.2 [Папки верхнего уровня](#structure-top-level)

> 2.3 [Папки разработчиков](#structure-developers)

> 2.4 [Карты](#structure-maps)

> 2.5 [Ядро игры](#structure-core)

> 2.6 [`Assets` и `AssetTypes`](#structure-assettypes)

> 2.7 [Большие наборы](#structure-large-sets)

> 2.8 [Библиотека материалов](#structure-material-library)


<a name="2.1"></a>
<a name="structure-folder-names"><a>
### 2.1 Названия папок

Все названия папок подчиняются единому набору правил.

<a name="2.1.1"></a>
#### 2.1.1 Всегда используйте ДельфиСтиль[<sup>*</sup>](#terms-cases)

ДельфиСтиль означает написание каждого слова строки с большой буквы, без пробелов и нижних пробелов. Например, `DesertEagle`, `RocketPistol`, и `ASeriesOfWords`.

См. [Использование верхнего и нижнего регистра](#terms-cases).

<a name="2.1.2"></a>
#### 2.1.2 Никогда не ставьте пробелы

В дополнение к [2.1.1](#2.1.1), не используйте пробелы. Пробелы могут вызвать падения различных средств компиляции и пакетной обработки. В идеале, путь к самому проекту тоже не должен содержать пробелы и быть расположен в папке вроде `D:\Project`, а не `C:\Пользователи\Моё имя\Мои документы\Unreal Projects`.

<a name="2.1.3"></a>
#### 2.1.3 Никогда не используйте символы юникода

_(Прим. пер.)_ Это также касается использования русского языка.

Если одного из ваших персонажей зовут 'Zoë', его папка должна называться `Zoe`. Символы юникода могут быть хуже [пробелов](#2.1.2) для инженерных инструментов, а некоторые инструменты UE не поддерживают символы юникода и в путях к файлам.

Если ваш проект страдает по [необъяснимым причинам](https://answers.unrealengine.com/questions/101207/undefined.html) от непонятных ошибок, а имя пользователя вашего компьютера содержит символы юникода (в т.ч. и русские буквы), то любой проект в папке `Мои документы` будет страдать аналогичным образом. Чаще всего достаточно переместить папку проекта в, скажем, `D:\Project`, и эти загадочные ошибки исчезнут.

Использование символов, отличных от `a-z`, `A-Z`, и `0-9`, напр. `@`, `-`, `_`, `,`, `*`, и `#` тоже может привести к неожиданным и трудно отслеживаемым последствиям на других платформах, в системах контроля версиями и неотшлифованных средствах разработки.

<a name="2.2"></a>
<a name="structure-top-level"><a>
### 2.2 Используйте папку верхнего уровня для всех ассетов вашего проекта

Все материалы разработки вашего проекта должны располагаться в папке, названной согласно самому проекту. Например, если проект называется 'Generic Shooter', то _всё_ его содержимое должно лежать в папке `Content/GenericShooter`.

> Папка `Developers` не для материалов разработки _вашего_ проекта, и потому не относится к папке проекта. См. [Папка Developers](#2.3) для подробного обоснования.

Есть несколько причин использования такого подхода.

<a name="2.2.1"></a>
#### 2.2.1 Отсутсвие глобальных ассетов

В стайл-гайдах по кодингу часто пишут о том, что вы не должны засорять глобальное пространство имён. Этот пункт следует этому же принципу. Если ассет существует вне проекта, велик риск роста несоблюдения структуры проекта, т.к. такой ассет становится дурным примером для других.

У каждого материала разработки должна быть своя цель, иначе он не принадлежит вашему проекту. Если ассет экспериментальный и не должен использоваться в проекте, его лучше положить в папку [`Developer`](#2.3).

<a name="2.2.2"></a>
#### 2.2.2 Уменьшение риска конфликтов при миграции

При работе над несколькими проектами команда нередко копирует ассеты из проекта в проект, если эти ассеты подходят и полезны сразу двум проектам. В таких случаях лучше произвести копию ресурсов через инструмент Migrate в Content Browser, т.к. он не только копирует сам ассет, но и все его зависимые ресурсы.

Эти зависимости легко генерируют проблемы при слиянии. Если у ваших двух проектов нет одноимённых с названием проекта папок в верхнем уровне контента, то ассеты с аналогичным названием (а то и уже адаптированные из другого проекта) могут быть уничтожены инструментом миграции.

К слову, это главная причина, по которой Epic требует такой же схемы в товарах Магазина.

После миграции, безопасное слияние ассетов может быть сделано через инструмент 'Replace References' content browser-а. После завершения миграции и слияния, лишняя папка на верхнем уровне проекта должна быть удалена. Это гарантирует _100%_ безопасность ваших миграций.

<a name="2.2.2e1"></a>
##### 2.2.2e1 Пример: главный материал

Скажем, вы сделали главный материал-шаблон в своём проекте и хотели бы использовать его в другом. Для этого вы мигрировали его. Если этот ассет не в верхней папке проекта, у него может быть название вроде `Content/MaterialLibrary/M_Master`, и, если в целевом проекте ещё нет такого главного материала, то ошибки не возникнет.

В ходе разработки проекта каждый такой главный материал дорабатывается под нужды конечного проекта.

Проблема возникает, когда, скажем, художник из одного проекта сделал симпатичный модульный набор статичных мешей, и кто-нибудь захотел включить этот набор в другой проект. Если художник — создатель набора — использовал экземпляры материала на основе главного `Content/MaterialLibrary/M_Master`, то при миграции возможна ошибка слияния с ранее мигрировавшим ассетом `Content/MaterialLibrary/M_Master`.

Эту ошибку трудно предупредить и объяснить. Человек, мигрирующий набор мешей, может быть не наслышан о разработке обоих главных материалов, и потому вовсе не осведомлён о том, что меши зависят от экземпляров материалов, которые, в свою очередь, зависят от главного материала. Но инструмент Migrate должен собрать всю сеть зависимостей с целью последующей работоспособности мигрированных ассетов, и поэтому захватит `Content/MaterialLibrary/M_Master` с исходного проекта, чем перезапишет аналогичный файл в конечном проекте.

Если эти материалы не совместимы _в принципе_, то велик риск обрушить всю библиотеку материалов вашего проекта. А ведь всё по причине отсутствия папки для проекта на верхнем уровне! Так простое перемещение мешей может наделать массу лишней работы.

<a name="2.2.3"></a>
#### 2.2.3 Примеры, шаблоны и товары с Магазина безопасны (почти)

В дополнение к [2.2.2](#2.2.2): если член команды решит добавить пример, файлы шаблона или товар с Магазина, эти ассеты гарантированно не будут пересекаться с файлами вашего проекта, т.к. у них всех есть своя папка верхнего уровня (в том случае, если имена между всеми ними и вашим проектом уникальны).

Тем не менее, нельзя на 100% доверять товарам с Магазина — не все из них следуют [правилу папки верхнего уровня](#2.2). Существует множество ассетов, где большая часть контента которых расположена в папке верхнего уровня, но при этом также используется контент из примеров движка (напр., шаблоны вроде FirstPersonShooter или Starter Content Pack). Эти ассеты из примеров могут быть изменены под нужды товара. Также, карты из этих примеров засоряют корневую папку `Content` и тоже могут пересекаться.

Если придерживаться правилу [2.2](#2.2), худшим сценарием будет использование нескольких товаров с магазина, которые зависят от одного и того же проекта-шаблона. Они могут повредить друг друга, но если именно ваши ассеты располагаются в отдельной папке ресурсов проекта, такой конфликт не затронет ваши наработки.

#### 2.2.4 DLC, подпроектами, патчами проще управлять

Если вы планируете выпустить DLC для своего проекта, или же в нём есть несколько связанных подпроектов, все ассеты этих DLC и подпроектов должны находиться в своих папках верхнего уровня. Такие подпроекты затем могут быть мигрированы из проекта или просто не участвовать в сборке. Техника создания индивидуальных папок верхнего уровня помогает с лёгкостью исключить DLC из выпечки основного проекта. Подпроекты также мигрируются с наименьшими усилиями. А если вам нужно в патче, например, заменить один материал или ввести специфичный ассет, меняющий поведение игры, но при этом вы не хотите ломать главный проект, все эти изменения тоже можно вывести в отдельную папку.

<a name="2.3"></a>
<a name="structure-developers"></a>
### 2.3 Используйте папку `Developers` для локального тестирования

Очень часто во время разработки проекта участники команды создают, в некотором роде, "песочницу", где они проводят свои эксперименты без влияния на главный проект. Так как такая практика осуществляется на постоянной основе, члены команды могут пожелать загрузить их ассеты в систему контроля версий. Не все команды требуют использования папки `Developers`, но те, что её используют, часто испытывают одни и те же проблемы с загруженными в систему контроля версиями ассетами.

Участники команды могут по случайности начать использовать те ассеты, которые ещё не готовы к этому, а затем, при их удалении, вызывают ошибки. Например, художник может дорабатывать набор модульных статичных мешей и всё ещё корректирует их размерность и соответствие сетке. Если левел-дизайнер обнаружит такой набор в главной папке проекта, он может использовать набор во всём уровне, не зная, что этот набор позднее будет претерпевать серьёзные изменения (не исключая удаление набора). Следствием этой проблемы будет масса переделок для всей команды.

Если эти модульные меши располагаются в папке разработчиков, у левел-дизайнера не было бы причин использовать этот набор, и проблемы бы не возникло. У Content Browser есть специальная настройка в View Options, которая прячет папки разработчиков (и по умолчанию она включена), что делает случайное использование экспериментальных ресурсов невозможным.

Как только ассеты готовы, художнику достаточно переместить эти материалы разработки в соответствующую папку проекта и подфиксить редиректоры. По сути, это "продвижение" ассетов из экспериментальной зоны в продакшн.

<a name="2.4"></a>
<a name="structure-maps"></a>
### 2.4 Все уровни[<sup>*</sup>](#terms-level-map) располагаются в отдельной папке под названием Maps

Файлы уровней отличаются от других, и нормальной практикой считается использование своей системы наименований, особенно, если команда работает с подуровнями или стримингом карт. Не важно, как организуются эти карты в вашем проекте — все они должны быть расположены в папке `/Content/Project/Maps`.

Возможность открыть определённую карту без необходимости объяснять, где она находится, серьёзно экономит время. Часто карты группируются в папки вроде `Maps/Campaign1/` или `Maps/Arenas`, но главное, что все они находятся в папке `/Content/Project/Maps`.

Такой подход также облегчает работу инженеров по сборке. Когда все карты в одной папке, не нужно перерывать весь проект в поиске предмета сборки/исключения из сборки. Становится труднее случайно не подготовить карту к сборке. Польза проявляется и при запуске скриптов для запекания освещения, а также в ходе процессов контроля качеством.

<a name="2.5"></a>
<a name="structure-core"></a>
### 2.5 Используйте папку `Core` ("Ядро") для особо важных блупринтов и других ассетов

Используйте папку `/Content/Project/Core` для тех ассетов, которые являются основой разработки вашего проекта. Например, основные `GameMode`, `Character`, `PlayerController`, `GameState`, `PlayerState` и связанные блупринты должны находиться именно здесь.

Это как знак "не трогай" для других участников команды. У не-инженеров обычно нет особых причин заглядывать в эту папку. При соблюдении хорошего стиля кодинга дизайнеры смогут выполнять все изменения, касающиеся геймплея, в дочерних классах. Левел-дизайнеры должны использовать заранее приготовленные блупринты в специально отведенных папках, вместо того, чтобы всё время использовать и модифицировать базовые классы.

Например, если в вашем проекте есть пикапы, которые могут быть расположены в уровне, для них должен быть базовый класс в папке `Core/Pickups`. Такой класс будет описывать базовое поведение пикапа. Конкретные пикапы, вроде аптечки или патронов уже будут располагаться в папке `/Content/Project/Placeables/Pickups/`. Гейм-дизайнеры могут спокойно редактировать эти пикапы по своему желанию, но они не должны трогать папку `Core/Pickups`, т.к. это косвенно может повредить работоспособность всех пикапов вообще.

<a name="2.6"></a>
<a name="structure-assettypes"></a>
### 2.6 Не создавайте папки `Assets` или `AssetTypes`

<a name="2.6.1"></a>
#### 2.6.1 Создание папки `Assets` является избыточным действием

Все ассеты и так являются ассетами.

<a name="2.6.2"></a>
#### 2.6.2 Создание папок `Meshes`, `Textures`, или `Materials` — лишнее

Все ассеты именуются с учётом их типа, и их названия уже включают указание типа в префиксе. Такие папки только добавляют избыточности в проект и легко заменяются фильтрами в Content Browser.

Для того, чтобы вывести только статичные меши в папке `Environment/Rocks/`, достаточно включить фильтр Static Mesh. Если все ассеты названы правильно, то они также будут отсортированы в алфавитном порядке, независимо от префиксов. Чтобы вывести и статичные, и скелетные меши, включите сразу два фильтра. Так вам не понадобится зажимать `Ctrl` и выделять несколько папок в проводнике Content Browser-а.

> Есть и небольшое преимущество в длине строки: префикс `S_` (статичный меш) — всего 2 символа, а папка `Meshes/` — семь.

Отсутствие таких папок устраняет ошибки с помещением статичных мешей в папку материалов.

<a name="2.7"></a>
<a name="structure-large-sets"></a>
### 2.7 Очень большие наборы ассетов получают свою собственную иерархию

Это псевдо-исключение к правилу [2.6](#2.6).

Есть определённые виды ассетов, которые образуют большой объём связанных по смыслу файлов, но каждый такой файл обладает своей уникальной целью. Чаще всего это папки с анимациями и аудио. Мы можем добавить новый уровень иерархии в папке тогда, когда эти подуровни образуют группы в 15+ семантически связанных файлов. Не забывайте делать этим подуровням чёткие и наполненные смыслом названия.

Например, есть анимации, которые используются несколькими персонажами — они должны находиться в папке `Characters/Common/Animations` , где могут быть поддиректории `Locomotion` или `Cinematic`.

> Это правило неприменимо к ассетам вроде текстур или материалов. Это норма, когда у папки `Rocks` огромное количество текстур, соответствующее аналогичному количеству камней; при этом каждая из этих текстур относится к небольшому количеству мешей и должна быть названа соответствующим образом. Не являются исключением и текстуры в [библиотеке материалов](#2.8).

<a name="2.8"></a>
<a name="structure-material-library"></a>
### 2.8 `MaterialLibrary` (библиотека материалов)

Если ваш проект использует главные материалы (материалы-шаблоны), слоистые материалы, или любую другую форму многократно используемых материалов и текстур, которые не принадлежат какому-нибудь подмножеству ассетов, они должны быть расположены в папке `Content/Project/MaterialLibrary`.

Так все "глобальные" материалы будут находиться в одном легкодоступном месте.

> Это также способствует политике "только экземпляры материалов" ('material instances only') в вашем проекте. Если все художники и рабочие материалы используют экземпляры материалы, то обычные материалы будут существовать только в пределах папки. Проверить соблюдение этой политики можно просто поиском основных материалов в папках, отличных от `MaterialLibrary`.

Папка `MaterialLibrary` необязательно должна состоять только из материалов. Общие текстуры-помощники, функции материалов и другие аналогичные ассеты могут храниться в этой же папке. Мы также можем объединять их в семантические группы папками. Например, общие текстуры с шумом можно объединить в папке `MaterialLibrary/Utility`.

Все материалы, предназначенные для тестирования и/или отладки должны располагаться в папке `MaterialLibrary/Debug`. Это позволяет убрать такие материалы при сборке релизной версии, а если они используются в версии для сборки, сообщение об ошибке укажет на эти связи.

<a name="2.9"></a>
<a name="structure-no-empty-folders"></a>
### 2.9 No Empty Folders

There simply shouldn't be any empty folders. They clutter the content browser.

If you find that the content browser has an empty folder you can't delete, you should perform the following:
1. Be sure you're using source control.
1. Immediately run Fix Up Redirectors on your project.
1. Navigate to the folder on-disk and delete the assets inside.
1. Close the editor.
1. Make sure your source control state is in sync (i.e. if using Perforce, run a Reconcile Offline Work on your content directory)
1. Open the editor. Confirm everything still works as expected. If it doesn't, revert, figure out what went wrong, and try again.
1. Ensure the folder is now gone.
1. Submit changes to source control.

**[⬆ Back to Top](#table-of-contents)**


<a name="3"></a>
<a name="bp"></a>
## 3. Блупринты

Этот раздел направлен на блупринты и их внутреннее обустройство. Где возможно, эти правила подчиняются [стандарту кодинга Epic](https://docs.unrealengine.com/latest/INT/Programming/Development/CodingStandard).

Remember: Blueprinting badly bears blunders, beware! (Phrase by [KorkuVeren](http://github.com/KorkuVeren))

### Подразделы

> 3.1 [Компиляция](#bp-compiling)

> 3.2 [Переменные](#bp-vars)

> 3.3 [Functions](#bp-functions)

> 3.4 [Graphs](#bp-graphs)

<a name="3.1"></a>
<a name="bp-compiling"></a>
### 3.1 Компиляция

Все блупринты должны компилиться без предупреждений и ошибок. Вы должны исправить все предупреждения и ошибки при первой возможности, т.к. они сразу могут превратиться в снежный ком проблем и вызвать непредвиденное поведение.

*Никогда не отправляйте* (submit) сломанные блупринты в систему контроля версиями. Если вам нужно хранить их в системе контроля версий, отложите их (shelve).

Сломанные блупринты могут вызвать массу проблем — таких, как поломанные связи, некорректное поведение, падения при сборке, частые ненужные перекомпиляции. Один сломанный блупринт способен порушить всю вашу игру.

<a name="3.2"></a>
<a name="bp-vars"></a>
### 3.2 Переменные

The words `variable` and `property` may be used interchangeably.

#### Подразделы

> 3.2.1 [Именование](#bp-vars)

> 3.2.2 [`Editable`](#bp-vars-editable)

> 3.2.3 [Категории](#bp-vars-categories)

> 3.2.4 [Уровни доступа](#bp-vars-access)

> 3.2.5 [`Advanced`](#bp-vars-advanced)

> 3.2.6 [`Transient`](#bp-vars-transient)

> 3.2.7 [Переменные `Config`](#bp-vars-config)

<a name="3.2.1"></a>
<a name="bp-var-naming"></a>
#### 3.2.1 Именование

<a name="3.2.1.1"></a>
<a name="bp-var-naming-nouns"></a>
##### 3.2.1.1 Существительные

Все не-булевые переменные должны быть чёткими, недвусмысленными, описательными существительными.

<a name="3.2.1.2"></a>
<a name="bp-var-naming-case"></a>
##### 3.2.1.2 ДельфиСтиль

Все не-булевые переменные должны быть написаны в [ДельфиСтиле](#terms-cases).

<a name="3.2.1.2e"></a>
###### 3.2.1.2e Примеры:

* `Score`
* `Kills`
* `TargetPlayer`
* `Range`
* `CrosshairColor`
* `AbilityID`

<a name="3.2.1.3"></a>
<a name="bp-var-bool-prefix"></a>
##### 3.2.1.3 Префикс `b` для булевых переменных

Все булевы значения должны следовать ДельфиСтилю, но иметь префикс в виде малой `b`.

Например: `bDead` и `bEvil`, **но не** `Dead` и `Evil`.

Редактор блупринтов в UE4 распознаёт эту `b` и не выводит её при выводе удобочитаемого текста.

<a name="3.2.1.4"></a>
<a name="bp-var-bool-names"></a>
##### 3.2.1.4 Имена булевых значений

<a name="3.2.1.4.1"></a>
###### 3.2.1.4.1 Общая информация и независимые состояния

Все булевые переменные должны быть качественными прилагательными. Не включайте вопросительные слова, например, `Is`. Такие слова зарезервированы для функций.

Например: используйте `bDead` и `bHostile`, но **не** `bIsDead` и `bIsHostile`.

Старайтесь также не использовать в названиях глаголы (напр. `bRunning`). Глаголы, как правило, ведут к сложным состояниям.

<a name="3.2.1.4.2"></a>
###### 3.2.1.4.2 Сложные состояния

Не используйте булевы переменные для описания сложных и/или зависимых состояний. Это приводит к затруднённому управлению этих состояний и нечитабельности. Вместо этого используйте перечисление (Enum).

Например: описывая пушку, **не используйте** `bReloading` и `bEquipping`, если пушка не может одновременно заряжаться и быть в процессе экипировки. Обозначьте перечисление `EWeaponState` и используйте вместо булевых переменных одну переменную `WeaponState` соответствующего типа. Так добавлять новые состояния пушке будет проще.

Пример: **не используйте** `bRunning` ("Бежит"), если вам также нужны `bWalking` ("Ходит") и `bSprinting` ("Спринтует", кратковременное ускорение). Вам нужно перечисление с чёткими названиями вариантов.

<a name="3.2.1.5"></a>
<a name="bp-vars-naming-context"></a>
##### 3.2.1.5 Предметная область переменной определяется самим блупринтом, но не названием

Все названия переменных не должны быть избыточны и упоминать свой контекст, так как все переменные из блупринта уже обладают своим контекстом.

<a name="3.2.1.5e"></a>
###### 3.2.1.5e Пример:

Пусть у нас есть блупринт `BP_PlayerCharacter`.

**Нельзя**

* `PlayerScore`
* `PlayerKills`
* `MyTargetPlayer`
* `MyCharacterName`
* `CharacterSkills`
* `ChosenCharacterSkin`

Названия этих переменных избыточны. Если переменные описаны в `BP_PlayerCharacter`, то это значит, что они характеризуют именно `BP_PlayerCharacter`.

**Надо**

* `Score`
* `Kills`
* `TargetPlayer`
* `Name`
* `Skills`
* `Skin`

<a name="3.2.1.6"></a>
<a name="bp-vars-naming-atomic"></a>
##### 3.2.1.6 _Не включайте_ названия атомарных типов

Атомарные, или примитивные, переменные — это такие переменные, что описывают своё значение в простейшей форме — напимер, в виде булевого значения, целочисленного, вещественного, перечисления (Enum).

Строки (именно String, не Text!), Rotator и векторы тоже считаются атомарными в блупринтах и тоже не должны включать названия типа в своих именах. Тем не менее, с технической точки зрения они не являются атомарными.

> Хоть вектора и состоят каждый из трёх вещественных значений, с векторами часто работают как с единым целым. То же и с Rotator.

> _Нельзя_ считать Text атомарным типом, т.к. они включают в себе скрытый функционал по локализации. Атомным типом является `String`, но не `Text`.

Атомные переменные не должны включать название типа переменной в своём названии.

Например: используйте `Score`, `Kills` и `Description`, **но не** `ScoreFloat`, `FloatKills`, `DescriptionString`.

Единственное исключение этого правила — когда имеется ввиду "количество того-то" **и** когда использование имени без типа переменной приводит к затруднению чтения.

Например: генератор забора создаёт X досок. Это X нужно сохранить в переменной `NumBoards` или `BoardsCount`, но не `Boards`, т.к. `Boards` может уже относиться к массиву переменных типа `Board`.

<a name="3.2.1.7"></a>
<a name="bp-vars-naming-complex"></a>
##### 3.2.1.7 **Нужно** включать имена неатомарных типов в названиях переменных

Неатомартные, или сложные, переменные — это такие, что отражают свою информацию как набор атомарных переменных. Структуры, классы, интерфейсы, примитивы со скрытым поведением (вроде `Text` и `Name`) попадают под это правило.

> В то время, как массив атомарных значений — это список атомарных переменных, массивы не меняют "атомарность" типа переменных.

Эти переменные должны включать названия их типов, но также и подразумевать контекст использования.

Если класс _владеет_ экземпляром сложной переменной, напр. если у `BP_PlayerCharacter` есть `BP_Hat`, то она должна называться как тип переменной, без каких-либо изменений.

Например: используйте `Hat`, `Flag`, и `Ability`, **но не** `MyHat`, `MyFlag`, или `PlayerAbility`.

Если класс _не владеет_ значением сложной переменной, то нужно использовать существительное вместе с названием типа переменной.

Например: если у `BP_Turret` есть способность нацеливаться на `BP_PlayerCharacter`, она (туррель) должна хранить переменную `TargetPlayer` — так в контексте `BP_Turret` будет понятно, что это ссылка на другую переменную сложного типа, которой туррель не владеет.


<a name="3.2.1.8"></a>
<a name="bp-vars-naming-arrays"></a>
##### 3.2.1.8 Массивы

Массивы подчиняются правилам выше, но описываются во множественном числе.

Например: используйте `Targets`, `Hats` и `EnemyPlayers`, **но не** `TargetList`, `HatArray`, `EnemyPlayerArray`.


<a name="3.2.2"></a>
<a name="bp-vars-editable"></a>
#### 3.2.2 Редактируемые (`Editable`) переменные

Все переменные, которые спокойно можно менять с целью настройки поведения блупринта, должны быть отмечены как  `Editable`.

Аналогично, все те переменные, которые небезопасно редактировать и которые не должны быть раскрыты дизайнерам, не должны быть отмечены как `Editable`, за исключением тех случаев, когда переменная требует флага `Expose On Spawn`.

Не помечайте переменные флагом `Editable` произвольным образом.

<a name="3.2.2.1"></a>
<a name="bp-vars-editable-tooltips"></a>
##### 3.2.2.1 Подсказки

Все переменные типа `Editable`, включая те, что были помечены так только из-за флага `Expose On Spawn`, должны иметь своё описание в поле `Tooltip`, которое должно показывать, как изменение этого значения меняет поведение блупринта.

<a name="3.2.2.2"></a>
<a name="bp-vars-editable-ranges"></a>
##### 3.2.2.2 Слайдеры и пределы допустимых значений

Все переменные с флагом `Editable` должны использовать слайдеры (Slider) и пределы допустимых значений (Value Range), если есть хоть какое-нибудь значение, которое _не должно_ использоваться.

Пример: блупринт, генерирующий забор, может иметь редактируемую переменную `BoardsCount`, и значение -1 не будет являться для него рабочим. Используйте пределы допустимых значений, чтобы обозначить 0 как минимальное значение.

Если редактируемая переменная используется в Construction Script, у неё должен быть настроенный слайдер (Slider Range), который препятствует назначению таких значений, что могут обрушить редактор.

Пределы допустимых значений нужно устанавливать только тогда, когда известны границы этих значений. Если слайдер предотвращает случайный ввод слишком больших значений, то неустановленное значение пределов всё же позволяет указать значения вне диапазона слайдера — "опасные", но всё ещё валидные.

<a name="3.2.3"></a>
<a name="bp-vars-categories"></a>
#### 3.2.3 Категории

Если у класса совсем немного переменных, то использование категорий не требуется.

Если у класса есть некоторое количество переменных (5-10), все переменные с флагом `Editable` должны обладать своей нестандартной категорией. Для общих переменных создаётся категория `Config`.

Если у класса большое количество переменных, то все переменные с флагом `Editable` должны быть помещены в подкатегории внутри `Config`. Нередактируемые переменные (без флага `Editable`) должны быть помещены в отдельные категории с понятными названиями.

> Вы можете создавать подкатегории, используя символ вертикальной черты `|`, напр. `Config | Animations`.

Пример: набор переменных оружия может быть расположен в следующей иерархии:

    |-- Config
    |   |-- Animations
    |   |-- Effects
    |   |-- Audio
    |   |-- Recoil
    |   |-- Timings
    |-- Animations
    |-- State
    |-- Visuals

<a name="3.2.4"></a>
<a name="bp-vars-access"></a>
#### 3.2.4 Уровень доступа переменных

В C++ есть реализация уровня доступа переменных. Уровень доступа `Public` означает, что все экземпляры любых классов могут получить доступ к этой переменной. Переменные `Protected` могут использованы только самим классом и дочерними классами. `Private` значит, что только сам класс может видеть эти переменные (дочерние не видят).

В блупринтах, по крайней мере — на данный момент —, нет реализации уровня доступа переменных.

Считайте переменные с флагом `Editable` как публичные. Переменные без этого флага считайте как `Protected`.

<a name="3.2.4.1"></a>
<a name="bp-vars-access-private"></a>
##### 3.2.4.1 Закрытые (`Private`) переменные

В том случае, если не известно, должна ли быть переменная доступна только в самом классе, но не в дочерних, не отмечайте переменную как `Private`. Используйте `Protected` и закрывайте переменную только тогда, когда вы абсолютно уверены, что хотите ограничить использование переменных в дочерних классах.

<a name="3.2.5"></a>
<a name="bp-vars-advanced"></a>
#### 3.2.5 `Advanced Display`

Если переменная должна быть редактируема, но, в большинстве случаев, нетронута, отметьте её флагом `Advanced Display`. Переменная будет скрыта, но может быть отображена по клику стрелки в конце категории.

Сам флаг `Advanced Display` тоже является скрытым за этой стрелкой на панеле `Details`.

<a name="3.2.6"></a>
<a name="bp-vars-transient"></a>
#### 3.2.6 `Transient`

Такие переменные не требуют сохранения и загрузки их значения и изначально равны нулю (zero или null). Они полезны для тех случаев, когда требуется ссылка на других объектов и актёров, не известная до запуска игры. Это предотвращает сохранение ссылки на эту переменную внутри редактора и ускоряет процесс сохранения и загрузки класса.

Because of this, all transient variables should always be initialized as zero or null. To do otherwise would result in hard to debug errors.

<a name="3.2.7"></a>
<a name="bp-vars-config"></a>
#### 3.2.7 Флаг `Config Variable`

Не используйте флаг `Config Variable`. Дизайнерам будет труднее из-за этого контроллировать поведение блупринта. Этот флаг используется только в C++ для редко меняющихся значений, как если бы они были под двойным флагом `Advanced Display`.

<a name="3.3"></a>
<a name="bp-functions"></a>
### 3.3 Functions, Events, and Event Dispatchers

This section describes how you should author functions, events, and event dispatchers. Everything that applies to functions also applies to events, unless otherwise noted.

<a name="3.3.1"></a>
<a name="bp-funcs-naming"></a>
#### 3.3.1 Function Naming

The naming of functions, events, and event dispatchers is critically important. Based on the name alone, certain assumptions can be made about functions. For example:

* Is it a pure function?
* Is it fetching state information?
* Is it a handler?
* Is it an RPC?
* What is its purpose?

These questions and more can all be answered when functions are named appropriately.

<a name="3.3.1.1"></a>
<a name="bp-funcs-naming-verbs"></a>
#### 3.3.1.1 All Functions Should Be Verbs

All functions and events perform some form of action, whether its getting info, calculating data, or causing something to explode. Therefore, all functions should all start with verbs. They should be worded in the present tense whenever possible. They should also have some context as to what they are doing.

`OnRep` functions, event handlers, and event dispatchers are an exception to this rule.

Good examples:

* `Fire` - Good example if in a Character / Weapon class, as it has context. Bad if in a Barrel / Grass / any ambiguous class.
* `Jump` - Good example if in a Character class, otherwise, needs context.
* `Explode`
* `ReceiveMessage`
* `SortPlayerArray`
* `GetArmOffset`
* `GetCoordinates`
* `UpdateTransforms`
* `EnableBigHeadMode`
* `IsEnemy` - ["Is" is a verb.](http://writingexplained.org/is-is-a-verb)

Bad examples:

* `Dead` - Is Dead? Will deaden?
* `Rock`
* `ProcessData` - Ambiguous, these words mean nothing.
* `PlayerState` - Nouns are ambiguous.
* `Color` - Verb with no context, or ambiguous noun.

<a name="3.3.1.2"></a>
<a name="bp-funcs-naming-onrep"></a>
#### 3.3.1.2 Property RepNotify Functions Always `OnRep_Variable`

All functions for replicated with notification variables should have the form `OnRep_Variable`. This is forced by the Blueprint editor. If you are writing a C++ `OnRep` function however, it should also follow this convention when exposing it to Blueprints.

<a name="3.3.1.3"></a>
<a name="bp-funcs-naming-bool"></a>
#### 3.3.1.3 Info Functions Returning Bool Should Ask Questions

When writing a function that does not change the state of or modify any object and is purely for getting information, state, or computing a yes/no value, it should ask a question. This should also follow [the verb rule](#bp-funcs-naming-verbs).

This is extremely important as if a question is not asked, it may be assumed that the function performs an action and is returning whether that action succeeded.

Good examples:

* `IsDead`
* `IsOnFire`
* `IsAlive`
* `IsSpeaking`
* `IsHavingAnExistentialCrisis`
* `IsVisible`
* `HasWeapon` - ["Has" is a verb.](http://grammar.yourdictionary.com/parts-of-speech/verbs/Helping-Verbs.html)
* `WasCharging` - ["Was" is past-tense of "be".](http://grammar.yourdictionary.com/parts-of-speech/verbs/Helping-Verbs.html) Use "was" when referring to 'previous frame' or 'previous state'.
* `CanReload` - ["Can" is a verb.](http://grammar.yourdictionary.com/parts-of-speech/verbs/Helping-Verbs.html)

Bad examples:

* `Fire` - Is on fire? Will fire? Do fire?
* `OnFire` - Can be confused with event dispatcher for firing.
* `Dead` - Is dead? Will deaden?
* `Visibility` - Is visible? Set visibility? A description of flying conditions?

<a name="3.3.1.4"></a>
<a name="bp-funcs-naming-eventhandlers"></a>
#### 3.3.1.4 Event Handlers and Dispatchers Should Start With `On`

Any function that handles an event or dispatches an event should start with `On` and continue to follow [the verb rule](#bp-funcs-naming-verbs). The verb may move to the end however if past-tense reads better.

[Collocations](http://dictionary.cambridge.org/us/grammar/british-grammar/about-words-clauses-and-sentences/collocation) of the word `On` are exempt from following the verb rule.

`Handle` is not allowed. It is 'Unreal' to use `On` instead of `Handle`, while other frameworks may prefer to use `Handle` instead of `On`.

Good examples:

* `OnDeath` - Common collocation in games
* `OnPickup`
* `OnReceiveMessage`
* `OnMessageRecieved`
* `OnTargetChanged`
* `OnClick`
* `OnLeave`

Bad examples:

* `OnData`
* `OnTarget`
* `HandleMessage`
* `HandleDeath`

<a name="3.3.1.5"></a>
<a name="bp-funcs-naming-rpcs"></a>
#### 3.3.1.5 Remote Procedure Calls Should Be Prefixed With Target

Any time an RPC is created, it should be prefixed with either `Server`, `Client`, or `Multicast`. No exceptions.

After the prefix, follow all other rules regarding function naming.

Good examples:

* `ServerFireWeapon`
* `ClientNotifyDeath`
* `MulticastSpawnTracerEffect`

Bad examples:

* `FireWeapon` - Does not indicate its an RPC of some kind.
* `ServerClientBroadcast` - Confusing.
* `AllNotifyDeath` - Use `Multicast`, never `All`.
* `ClientWeapon` - No verb, ambiguous.


<a name="3.3.2"></a>
<a name="bp-funcs-return"></a>
#### 3.3.2 All Functions Must Have Return Nodes

All functions must have return nodes, no exceptions.

Return nodes explicitly note that a function has finished its execution. In a world where blueprints can be filled with `Sequence`, `ForLoopWithBreak`, and backwards reroute nodes, explicit execution flow is important for readability, maintenance, and easier debugging.

The Blueprint compiler is able to follow the flow of execution and will warn you if there is a branch of your code with an unhandled return or bad flow if you use return nodes.

In situations like where a programmer may add a pin to a Sequence node or add logic after a for loop completes but the loop iteration might return early, this can often result in an accidental error in code flow. The warnings the Blueprint compiler will alert everyone of these issues immediately.

<a name="3.3.3"></a>
<a name="bp-graphs-funcs-node-limit"></a>
#### 3.3.3 No Function Should Have More Than 50 Nodes

Simply, no function should have more than 50 nodes. Any function this big should be broken down into smaller functions for readability and ease of maintenance.

The following nodes are not counted as they are deemed to not increase function complexity:

* Comment
* Route
* Cast
* Getting a Variable
* Breaking a Struct
* Function Entry
* Self

<a name="3.3.4"></a>
<a name="bp-graphs-funcs-description"></a>
#### 3.3.4 All Public Functions Should Have A Description

This rule applies more to public facing or marketplace blueprints, so that others can more easily navigate and consume your blueprint API.

Simply, any function that has an access specificer of Public should have its description filled out. 

<a name="3.3.5"></a>
<a name="bp-graphs-funcs-plugin-category"></a>
#### 3.3.5 All Custom Static Plugin `BlueprintCallable` Functions Must Be Categorized By Plugin Name

If your project includes a plugin that defines `static` `BlueprintCallable` functions, they should have their category set to the plugin's name or a subset category of the plugin's name.

For example, `Zed Camera Interface` or `Zed Camera Interface | Image Capturing`.

<a name="3.4"></a>
<a name="bp-graphs"></a>
### 3.4 Blueprint Graphs

This section covers things that apply to all Blueprint graphs.

<a name="3.4.1"></a>
<a name="bp-graphs-spaghetti"></a>
#### 3.4.1 No Spaghetti

Wires should have clear beginnings and ends. You should never have to mentally untangle wires to make sense of a graph. Many of the following sections are dedicated to reducing spaghetti.

<a name="3.4.2"></a>
<a name="bp-graphs-align-wires"></a>
#### 3.4.2 Align Wires Not Nodes

Always align wires, not nodes. You can't always control the size and pin location on a node, but you can always control the location of a node and thus control the wires. Straight wires provide clear linear flow. Wiggly wires wear wits wickedly. You can straighten wires by using the Straighten Connections command with BP nodes selected. Hotkey: Q

Good example: The tops of the nodes are staggered to keep a perfectly straight white exec line.
![Aligned By Wires](https://github.com/allar/ue4-style-guide/raw/master/images/bp-graphs-align-wires-good.png "Aligned By Wires")

Bad Example: The tops of the nodes are aligned creating a wiggly white exec line.
![Bad](https://github.com/allar/ue4-style-guide/raw/master/images/bp-graphs-align-wires-bad.png "Wiggly")

Acceptable Example: Certain nodes might not cooperate no matter how you use the alignment tools. In this situation, try to minimize the wiggle by bringing the node in closer.
![Acceptable](https://github.com/allar/ue4-style-guide/raw/master/images/bp-graphs-align-wires-acceptable.png "Acceptable")

<a name="3.4.3"></a>
<a name="bp-graphs-exec-first-class"></a>
#### 3.4.3 White Exec Lines Are Top Priority

If you ever have to decide between straightening a linear white exec line or straightening data lines of some kind, always straighten the white exec line.

<a name="3.4.4"></a>
<a name="bp-graphs-block-comments"></a>
#### 3.4.4 Graphs Should Be Reasonably Commented

Blocks of nodes should be wrapped in comments that describe their higher-level behavior. While every function should be well named so that each individual node is easily readable and understandable, groups of nodes contributing to a purpose should have their purpose described in a comment block. If a function does not have many blocks of nodes and its clear that the nodes are serving a direct purpose in the function's goal, then they do not need to be commented as the function name and  description should suffice.

<a name="3.4.5"></a>
<a name="bp-graphs-cast-error-handling"></a>
#### 3.4.5 Graphs Should Handle Casting Errors Where Appropriate

If a function or event assumes that a cast always succeeds, it should appropriately report a failure in logic if the cast fails. This lets others know why something that is 'supposed to work' doesn't. A function should also attempt a graceful recover after a failed cast if it's known that the reference being casted could ever fail to be casted.

This does not mean every cast node should have its failure handled. In many cases, especially events regarding things like collisions, it is expected that execution flow terminates on a failed cast quietly.

<a name="3.4.6"></a>
<a name="bp-graphs-dangling-nodes"></a>
#### 3.4.6 Graphs Should Not Have Any Dangling / Loose / Dead Nodes

All nodes in all blueprint graphs must have a purpose. You should not leave dangling blueprint nodes around that have no purpose or are not executed.

**[⬆ Back to Top](#table-of-contents)**


<a name="4"></a>
<a name="Static Meshes"></a>
<a name="s"></a>
## 4. Static Meshes

This section will focus on Static Mesh assets and their internals.

### Sections

> 4.1 [UVs](#s-uvs)

> 4.2 [LODs](#s-lods)

> 4.3 [Modular Socketless Snapping](#s-modular-snapping)

> 4.4 [Must Have Collision](#s-collision)

> 4.5 [Correct Scale](#s-scaled)

<a name="4.1"></a>
<a name="s-uvs"></a>
### 4.1 Static Mesh UVs

If Linter is reporting bad UVs and you can't seem to track it down, open the resulting `.log` file in your project's `Saved/Logs` folder for exact details as to why it's failing. I am hoping to include these messages in the Lint report in the future.

<a name="4.1.1"></a>
<a name="s-uvs-no-missing"></a>
#### 4.1.1 All Meshes Must Have UVs

Pretty simple. All meshes, regardless how they are to be used, should not be missing UVs.

<a name="4.1.2"></a>
<a name="s-uvs-no-overlapping"></a>
#### 4.1.2 All Meshes Must Not Have Overlapping UVs for Lightmaps

Pretty simple. All meshes, regardless how they are to be used, should have valid non-overlapping UVs.

<a name="4.2"></a>
<a name="s-lods"></a>
### 4.2 LODs Should Be Set Up Correctly

This is a subjective check on a per-project basis, but as a general rule any mesh that can be seen at varying distances should have proper LODs.

<a name="4.3"></a>
<a name="s-modular-snapping"></a>
### 4.3 Modular Socketless Assets Should Snap To The Grid Cleanly

This is a subjective check on a per-asset basis, however any modular socketless assets should snap together cleanly based on the project's grid settings.

It is up to the project whether to snap based on a power of 2 grid or on a base 10 grid. However if you are authoring modular socketless assets for the marketplace, Epic's requirement is that they snap cleanly when the grid is set to 10 units or bigger.

<a name="4.4"></a>
<a name="s-collision"></a>
### 4.4 All Meshes Must Have Collision

Regardless of whether an asset is going to be used for collision in a level, all meshes should have proper collision defined. This helps the engine with things such as bounds calculations, occlusion, and lighting. Collision should also be well-formed to the asset.

<a name="4.5"></a>
<a name="s-scaled"></a>
### 4.5 All Meshes Should Be Scaled Correctly

This is a subjective check on a per-project basis, however all assets should be scaled correctly to their project. Level designers or blueprint authors should not have to tweak the scale of meshes to get them to confirm in the editor. Scaling meshes in the engine should be treated as a scale override, not a scale correction.

**[⬆ Back to Top](#table-of-contents)**


<a name="5"></a>
<a name="Niagara"></a>
<a name="ng"></a>
## 5. Niagara

This section will focus on Niagara assets and their internals.

### Sections

> 5.1 [Naming Rules](#ng-rules)

<a name="5.1"></a>
<a name="ng-rules"></a>
### 5.1 No Spaces, Ever

As mentioned in [00.1 Forbidden Identifiers](#00), spaces and all white space characters are forbidden in identifiers. This is especially true for Niagara systems as it makes working with things significantly harder if not impossible when working with HLSL or other means of scripting within Niagara and trying to reference an identifier.

(Original Contribution by [@dunenkoff](https://github.com/Allar/ue5-style-guide/issues/58))


**[⬆ Back to Top](#table-of-contents)**


<a name="6"></a>
<a name="Levels"></a>
<a name="levels"></a>
## 6. Levels / Maps

[See Terminology Note](#terms-level-map) regarding "levels" vs "maps".

This section will focus on Level assets and their internals.

### Sections

> 6.1 [No Errors Or Warnings](#levels-no-errors-or-warnings)

> 6.2 [Lighting Should Be Built](#levels-lighting-should-be-built)

> 6.3 [No Player Visible Z Fighting](#evels-no-visible-z-fighting)

> 6.4 [Marketplace Specific Rules](#evels-levels-mp-rules)

<a name="6.1"></a>
<a name="levels-no-errors-or-warnings"></a>
### 6.1 No Errors Or Warnings

All levels should load with zero errors or warnings. If a level loads with any errors or warnings, they should be fixed immediately to prevent cascading issues.

You can run a map check on an open level in the editor by using the console command "map check".

Please note: Linter is even more strict on this than the editor is currently, and will catch load errors that the editor will resolve on its own.

<a name="6.2"></a>
<a name="levels-lighting-should-be-built"></a>
### 6.2 Lighting Should Be Built

It is normal during development for levels to occasionally not have lighting built. When doing a test/internal/shipping build or any build that is to be distributed however, lighting should always be built.

<a name="6.3"></a>
<a name="levels-no-visible-z-fighting"></a>
### 6.3 No Player Visible Z Fighting

Levels should not have any [z-fighting](https://en.wikipedia.org/wiki/Z-fighting) in all areas visible to the player. 

<a name="6.4"></a>
<a name="levels-mp-rules"></a>
### 6.4 Marketplace Specific Rules

If a project is to be sold on the UE4 Marketplace, it must follow these rules.

<a name="6.4.1"></a>
<a name="levels-mp-rules-overview"></a>
### 6.4.1 Overview Level

If your project contains assets that should be visualized or demoed, you must have a map within your project that contains the name "Overview".

This overview map, if it is visualizing assets, should be set up according to [Epic's guidelines](http://help.epicgames.com/customer/en/portal/articles/2592186-marketplace-submission-guidelines-preparing-your-assets#Required%20Levels%20and%20Maps).

For example, `InteractionComponent_Overview`.

<a name="6.4.2"></a>
<a name="levels-mp-rules-demo"></a>
### 6.4.2 Demo Level

If your project contains assets that should be demoed or come with some sort of tutorial, you must have a map within your project that contains the name "Demo". This level should also contain documentation within it in some form that illustrates how to use your project. See Epic's Content Examples project for good examples on how to do this.

If your project is a gameplay mechanic or other form of system as opposed to an art pack, this can be the same as your "Overview" map.

For example, `InteractionComponent_Overview_Demo`, `ExplosionKit_Demo`.

**[⬆ Back to Top](#table-of-contents)**


<a name="7"></a>
<a name="textures"></a>
## 7. Textures

This section will focus on Texture assets and their internals.

### Sections

> 7.1 [Dimensions Are Powers of 2](#textures-dimension)

> 7.2 [Texture Density Should Be Uniform](#textures-dimension)

> 7.3 [Textures Should Be No Bigger than 8192](#textures-max-size)

> 7.4 [Correct Texture Groups](#textures-textures-group)

<a name="7.1"></a>
<a name="textures-dimensions"></a>
### 7.1 Dimensions Are Powers of 2

All textures, except for UI textures, must have its dimensions in multiples of powers of 2. Textures do not have to be square.

For example, `128x512`, `1024x1024`, `2048x1024`, `1024x2048`, `1x512`.

<a name="7.2"></a>
<a name="textures-density"></a>
### 7.2 Texture Density Should Be Uniform

All textures should be of a size appropriate for their standard use case. Appropriate texture density varies from project to project, but all textures within that project should have a consistent density.

For example, if a project's texture density is 8 pixel per 1 unit, a texture that is meant to be applied to a 100x100 unit cube should be 1024x1024, as that is the closest power of 2 that matches the project's texture density. 

<a name="7.3"></a>
<a name="textures-max-size"></a>
### 7.3 Textures Should Be No Bigger than 8192

No texture should have a dimension that exceeds 8192 in size, unless you have a very explicit reason to do so. Often, using a texture this big is simply just a waste of resources.

<a name="7.4"></a>
<a name="textures-group"></a>
### 7.4 Textures Should Be Grouped Correctly

Every texture has a Texture Group property used for LODing, and this should be set correctly based on its use. For example, all UI textures should belong in the UI texture group.

**[⬆ Back to Top](#table-of-contents)**

## Вклад сообщества

* [Michael Allar](http://allarsblog.com): [GitHub](https://github.com/Allar), [Twitter](https://twitter.com/michaelallar)
* [CosmoMyzrailGorynych](https://github.com/CosmoMyzrailGorynych)
* [billymcguffin](https://github.com/billymcguffin)
* [akenatsu](https://github.com/akenatsu)

## Лицензия

Copyright (c) 2016 Gamemakin LLC

См. файл [LICENSE](/LICENSE)

**[ Наверх](#toc)**


## Правки

Мы поощряем клонирование этого репозитория с целью адаптации под правила вашей команды. Ниже, вы можете указать свои правки, чтобы периодически обновлять стайл-гайд без ошибок слияния.

# };
